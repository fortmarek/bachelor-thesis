%---------------------------------------------------------------
\chapter{Introduction}
%---------------------------------------------------------------
\setcounter{page}{1}

\section{Motivation, Focus of Thesis}

Theory of finite automata is an important part of computer science curriculum at FIT CTU in Prague and other universities around the world. And although there is a lot of resources one can learn from, there is a lack of those that utilize modern tools. One of such modern tools is iPad (and touch devices in general). This thesis will fill in this gap as the result will be a finite automata editor application for iPad.

Furthermore, I will expand on the recent work done at FIT CTU in Prague concerning development of algorithms library and, more importantly for this thesis, finite automata algorithms including simulating input. This library is named \href{https://alt.fit.cvut.cz/}{Algorithms Library Toolkit} (ALT) \cite{alt} and it has been open sourced.

The main motivation of this thesis is to improve how students learn finite automata and more specifically, enhance the current course BI-AAG that is taught at FIT CTU in Prague. It is also an opportunity to try out algorithms library in practice and create a concrete example of how it can be leveraged.

\section{Thesis Goals}

The main goal of this thesis is to implement a prototype of an automata editor for iPad. This application should enable users to create and edit finite automata with emphasis on touch-based input.
I will also study the web interface of ALT \cite{state-maker} \cite{web-alt}, ALT itself focusing on design and drawing of finite automata, the possibilities of strokes detection on touch devices, and the approaches of shape detection, especially those used in automata drawing on iOS platform.

After the initial study of current approaches and theory, I will implement a prototype of a finite automata editor iPad app that will be capable of recognizing finite automaton elements from strokes and simulating input.

I will then conduct usability testing to assess the usability and shortcomings of the prototype.

\section{Thesis Structure}

Let me now introduce you to the structure of the rest of the thesis:

\begin{itemize}
\item In \textbf{Chapter 2} I will go over the theoretical concepts to properly explain terms and concepts on which it will be built upon later.

\item \textbf{Chapter 3} is concerned with the analysis of already existing solutions of creating automata editor, the existing ALT web interface and ALT itself.

\item \textbf{Chapter 4} is about the design of the editor itself.

\item In \textbf{Chapter 5} I will write about the implementation.

\item \textbf{Chapter 6} will go into the specifics of user testing and its outcomes.

\item \textbf{Conclusion} is the last chapter of this thesis where I will assess the success of fulfilling aforementioned goals and lay out possible future development.

\end{itemize}

\chapter{Theory}
\label{chap:theory}

Firstly,  I will need to define terms and formal definitions concerning mainly finite automata theory, as that is the main subject of this thesis, and then machine learning as some of its concepts were important during the implementation. 

\section{Formal Languages and Grammars}
 
The following definitions are taken from Automata and Grammars by Eliška Šestáková \cite{automata-and-grammars}, Introduction to Automata Theory, Languages, and Computation \cite{introduction-automata}, and materials from BIE-AAG course \cite{lectures}.

\subsection{Formal Languages}

\begin{definition}
Alphabet (conventionally denoted by $\Sigma$) is a finite set whose elements are called symbols.
\end{definition}
Alphabets therefore can be:
\begin{itemize}
    \item $\Sigma$ = \{0, 1\}
    \item $\Sigma$ = \{a, b, c, d, e\}
    \item $\Sigma$ = \{one, two\}
\end{itemize}

\begin{definition}
String (word) over an alphabet is a finite sequence of symbols from that alphabet.
\end{definition}
\begin{itemize}
    \item $\epsilon$ - \textit{empty string} (string with zero occurences of symbols)
    \item $\Sigma^{*}$ - set of all strings over $\Sigma$
    \item $\Sigma^{+}$ - set of all nonempty strings over $\Sigma$
\end{itemize}
For a binary alphabet $\Sigma$ = \{0, 1\} $\epsilon$, 1001, 100, 1, 001 are all strings over the alphabet $\Sigma$.

\begin{definition}
Formal language L over an alphabet $\Sigma$ is any subset of all the strings over $\Sigma$ - i.e., $L \subseteq \Sigma$
\end{definition}
For a binary alphabet $\Sigma$ = \{0, 1\} a formal language over $\Sigma$ is then subsets of \textit{all} binary strings. We can denote the language either by:
\begin{itemize}
    \item enumeration notation where all possible strings in the language are listed, e.g.: $\textit{L}_1 = \{\epsilon\}, \textit{L}_2 = \{1\}, \textit{L}_3 = \{0, 00, 000, 01\}$.
    \item set-builder notation where the languages are described in the following way: \{ w $\mid$ something about w \}. Examples are: $\textit{L}_4 = \{\textit{w} \mid \textit{w} \in {0,1}^* \wedge \left|\textit{w}\right| mod 2 = 0\}$, $\textit{L}_5 = \{0^\textit{n}1^\textit{n} : \textit{n} \in \mathbb{N}_0\}$.
\end{itemize}

\subsection{Grammar}

Grammars are used to describe languages. Below you can find how they are defined:

\begin{definition}
    \textit{Grammar} is a quadruple of G = (N, $\Sigma$, P, S) where:
\end{definition}
\begin{itemize}
    \item \textit{N} is a finite non-empty set of nonterminal symbols.
    \item $\Sigma$ is a finite set of terminal symbols ($\Sigma$ $\cap$ \textit{N} = $\emptyset$). Note that \textit{N} $\cap$ $\Sigma$ = $\emptyset$.
    \item \textit{P} is a finite set of \textit{production rules}, assuming the following form:\\

    \centerline{$\alpha\textit{A}\beta \rightarrow \gamma$ ($\alpha, \beta, \gamma \in (\textit{N} \cup \Sigma)^*$)}
\end{itemize}

The following is an example of a grammar that describes the language \textit{L} = $\{01^\textit{n}0 : \textit{n} \in \mathbb{N}_0\}$:
Grammar \textit{G} = (\{\textit{A}, \textit{S}\}, \{0, 1\}, \textit{P}, \textit{S}) where \textit{P}:
\begin{itemize}
    \item \textit{S} $\rightarrow$ 0\textit{A}
    \item \textit{A} $\rightarrow$ 1\textit{A}
    \item \textit{A} $\rightarrow$ 0
\end{itemize}

\subsection{Chomsky Classification of Grammars}

Grammars are divided into four classes where they differ in their production rules. 

\begin{definition}
    Let G = (N, $\Sigma$, P, S). We say that G is:
\end{definition}
\begin{enumerate}
    \item \textit{Unrestricted grammar} (type 0), if every rule is in the form of:
    
    \centerline{$\alpha\textit{A}\beta \rightarrow \gamma$ ($\alpha, \beta, \gamma \in (\textit{N} \cup \Sigma)^*$, $\textit{A} \in \textit{N}$)}
    \item \textit{Context-sensitive} (type 1), if every rule is in the form of:

    \centerline{$\gamma\textit{A}\delta \rightarrow \gamma\alpha\delta$ ($\gamma, \delta \in (\textit{N} \cup \Sigma)^*$, $\textit{a} \in (\textit{N} \cup \Sigma)^+$)}
    or in the form of $\textit{S} \rightarrow \epsilon$ if \textit{S} is not present on the right hand side of any rule of a given grammar.
    \item \textit{Context-free grammar} (type 2) if every rule is in the form of:

    \centerline{$\textit{A} \rightarrow \alpha$ $(\textit{A} \in \textit{N}, \alpha \in (N \cup \Sigma)^*)$}
    \item \textit{Regular grammar} (type 3), if every rule is in the form of:

    \centerline{$\textit{A} \rightarrow \textit{a}$ or $\textit{A} \rightarrow \textit{aB}$ $(\textit{a} \in \Sigma, \textit{A}, \textit{B} \in \textit{N})$}
    or in the form of $\textit{S} \rightarrow \epsilon$ if \textit{S} is not present on the right hand side of any rule of a given grammar.
\end{enumerate}

\subsection{Classification of Languages}
Classification of languages, also known as the Chomsky hierarchy, has the following definition:
\begin{definition}
    We say that language is:
\end{definition}
\begin{enumerate}
    \item \textit{formal} if it is a formal language but is neither regular, context-free, context-sensitive, nor recursive enumerable. These languages are not recognized by Turing machine.
    \item \textit{recursively enumerable} if and only if $\exists$ unrestricted grammar which generates it
    \begin{itemize}
        \item recognized by Turing machine
    \end{itemize}
    \item \textit{context-sensitive} if and only if $\exists$ context-sensitive grammar which generates it
    \begin{itemize}
        \item recognized by linear bounded Turing machine
    \end{itemize}
    \item \textit{context-free} if and only if $\exists$ context-free grammar which generates it
    \begin{itemize}
        \item recognized by a nondeterministic pushdown automaton
    \end{itemize}
    \item \textit{regular} if and only if $\exists$ regular grammar that generates it
    \begin{itemize}
        \item recognized by finite automaton
    \end{itemize}
\end{enumerate}

In this thesis we will be mainly interested in regular languages / grammars since those are recognized by finite automata. Finite automata will be defined in the following section.

\section{Finite Automata}

The final editor app will be for finite automata, therefore they are very important for this thesis. Informally, a finite automaton is a model for simple computation. States, that serve as memory, and transitions together form a \textit{control unit}. Along with a control unit, the finite automaton has a \textit{read-only input tape}, which is divided into individual cells, and the \textit{head} that scans the input tape as the automaton continuously reads it, cell by cell. Automaton starts in its initial state and with head pointing at the first cell. As the input is read, the head moves until it has read all of the input tape. If there is a missing transition for an input, the automaton does not accept the input. Otherwise, it accepts the input if it is in an end state at the end of the input.

Let's define a finite automaton formally:
\begin{definition}
    Finite automaton is a quintuple \textit{M} = (\textit{Q}, $\Sigma$, $\delta$, $\textit{q}_0$, \textit{F}) where:
    \begin{itemize}
        \item \textit{Q} is a finite non-empty set of states
        \item $\Sigma$ is a finite input alphabet
        \item $\delta$ is the transition function (the exact definition is determined by which type of finite automaton it is - see below)
        \item $\textit{q}_0 \in \textit{Q}$ is the initial state
        \item $\textit{F} \subseteq \textit{Q}$ is the set of initial states
    \end{itemize}
\end{definition}

Finite automaton can also be either \textit{deterministic} finite automaton or \textit{nondeterministic} finite automaton. This dictates the exact definition of $\delta$ - transition function.
For deterministic finite automaton (DFA) the definition of $\delta$ is:\\
\centerline{$\delta$ is a mapping from \textit{Q} $\times$ $\Sigma$ to \textit{Q}}
$\delta$ for nondeterministic finite automaton (NFA) is defined as:\\
\centerline{$\delta$ is a mappping from \textit{Q} $\times$ $\Sigma$ into the set of all subsets \textit{Q} (denoted by $2^\textit{Q}$)}
Expanding upon the difference between the definition of the transition function:
\begin{itemize}
    \item DFA can only transition from one state to another, e.g. from $\textit{q}_0$ to $\textit{q}_1$ ($\textit{q}_0$, $\textit{q}_1$ $\in$ \textit{Q})
    \item NFA can transition to a set of states, e.g. from $\textit{q}_0$ to $\textit{q}_1$ ($\textit{q}_0$, $\textit{q}_1$, $\textit{q}_2$ $\in$ \textit{Q})
\end{itemize}
If we change the definition of NFA's $\delta$ to a mapping from \textit{Q} $\times$ ($\Sigma \cup \{\epsilon\}$) we allow, what are called, $\epsilon$-transitions that allow us to move to a different state while not reading any input from the tape. This finite automaton is then called \textit{nondeterministic finite automaton with $\epsilon-transitions$}.

\subsection{Representation of Finite Automata}

Finite automata's transition functions $\delta$ are generally represented in the form of:
\begin{itemize}
    \item \textit{Formal notation}\\
    (NFA) $\delta$(\textit{S}, 0) = \{\textit{S}, \textit{A}\} (transition from the state \textit{S} and symbol 0 to the states \textit{S} and \textit{A})\\
    (DFA) $\delta$(\textit{A}, 0) = \textit{B} (transition from the state \textit{A} and symbol 0 to a single state, not a set of states, \textit{B})
    \item \textit{Weighted directed graph} (state diagram)\\
    Automata can be represented graphically as directed weighted graphs. Each state is represented as a vertice in the graph and final states are recognized by being a double circle, instead of a single one. Initial state is the one with an incoming edge. The transitions are then directed edges between states. You can see FA represented as weighted directed graph in \ref{graph-representation}
    \item \textit{Table}\\
    Table representation has in the first column all states where initial state is marked with $\rightarrow$ while final states is marked with $\leftarrow$. In the first row, excluding the first column, there are symbols of the alphabet, $\Sigma$. In the rest of the rows are states (or a set of states) that will be transitioned to on a given input (defined in the first row). You can see an example of it in \ref{table-representation}.
\end{itemize}
\begin{figure}
\begin{tikzpicture}
    \node[state, initial] (q1) {$q_1$};
    \node[state, accepting, right of=q1] (q2) {$q_2$};
    \node[state, right of=q2] (q3) {$q_3$};
    \draw   (q1) edge[loop above] node{0} (q1)
            (q1) edge[above] node{1} (q2)
            (q2) edge[loop above] node{1} (q2)
            (q2) edge[bend left, above] node{0} (q3)
            (q3) edge[bend left, below] node{0, 1} (q2);
\end{tikzpicture}
\caption{FA graph representation}\label{graph-representation}
\end{figure}
\begin{figure}
\begin{tabular}{||c|c|c||} 
    \hline
    $\delta_{NFA}$ & 0 & 1 \\ [0.5ex] 
    \hline\hline
    $\rightarrow \textit{S}$ & S & \textit{S}, \textit{A} \\ 
    \hline
    \textit{A} & \textit{B} & \\
    \hline
    $\leftarrow \textit{B}$ &  & \\
    \hline
\end{tabular}
\caption{FA table representation}\label{table-representation}
\end{figure}
In this thesis we will mostly be working with the representation in form of weighted directed graph as that is what will the user edit in the app.
This also concludes theory about finite automata and formal languages.

\section{Machine Learning}

Machine learning does not have an exact definition but e.g. in a book Foundations of Machine Learning it's loosely defined as "computational methods using experience to improve performance or to make accurate predictions" \cite{ml-foundations}. \textit{Experience} means something we know from the past that we can leverage for making predictions in the future. Usually, this experience comes in the form of data. The book Foundations of Machine Learning \cite{ml-foundations} and materials from BIE-VZD from FIT CTU in Prague \cite{vzd-lectures} will be used further in this section to define terms and concepts necessary for this thesis.

\subsection{Classification}

Machine learning, in order to cluster problems that can be solved in a similar way, have defined a few learning scenarios, most notably supervised and unsupervised learning. Learning scenario is a basic description of what type of data we have, how we receive the data and the test data that we use to evaluate the learning algorithm.

\begin{itemize}
    \item \textit{supervised learning}: Our goal is to explain \textit{variable Y} given \textit{independent variables} $\textit{X}_0$, $\textit{X}_1$, ..., $\textit{X}_{\textit{p} - 1}$. We do this by finding a "function" for which most of its examples the following holds:\\
    \centerline{\textit{Y} $\approx$ \textit{f}($\textit{X}_0$, $\textit{X}_1$, ..., $\textit{X}_{\textit{p} - 1}$)}
    \item \textit{unsupervised learning}: Our goal is to find structures of "similar" data. We do not predict any class and there is no clear way to assess the quality of an unsupervised learning algorithm since it is not clearly defined what the end result should be.
\end{itemize}

In this thesis we will be only interested in the supervised learning. We can also divide common problems that machine learning is trying to solve by learning tasks - that includes classification, regression, ranking, clustering, etc. Let's look more closely at classification which will be later used in the implementation.

\begin{itemize}
    \item Classification is a problem of assigning a category to each item.
\end{itemize}
It is also a problem solved via supervised learning. To expand on the definition of supervised learning from above, classification is a special case where \textit{Y} has only a few (countable amount) of values. The simplest example of classification is \textit{binary classification}. E.g. we want to predict whether a patient has flu and our data - gender of a patient, person can leave the bed - can be represented in a binary format (yes/no).

\chapter{Analysis}
\label{chap:analysis}

In the analysis I will study the following:
\begin{itemize}
    \item existing applications that enable users edit finite automata
    \item ALT itself, focusing on design and drawing of finite automata
    \item possibilites of detection of strokes on touch devices.
\end{itemize}

\section{Existing Applications}

This section will be concerned with the study of existing applications - be it applications for mobile or web.

\subsection{ALT Web Interface}

ALT web interface has been built as a part of bachelor's thesis made by Michael Vrána \cite{web-alt} leveraging work already done in ALT itself. ALT web interface uses Pipe-and-Filter \cite{pipe-and-filter} architecture to easily combine input and ouputs of the individual algorithms that ALT offers which can be seen in figure \ref{alt-web-interface-screen}. Apart from ALT algorithms it also includes finite automata editor done by Petr Svoboda \cite{state-maker}.

\begin{figure}
    \includegraphics[width=\textwidth]{alt-web-interface}
    \caption{ALT web interface screenshot}\label{alt-web-interface-screen}
\end{figure}

This finite automata editor is called Statemaker and you can see a screenshot of how it looks in figure \ref{statemaker-screen}. To summarize its capabilities - users can:
\begin{itemize}
    \item add states, as well as initial and final states
    \item add transitions between states
    \item edit transition string
    \item mark state as initial or final
    \item remove states and transitions
    \item import and export automaton in supported formats
    \item automatic positioning of transitions and states
\end{itemize}
All of the above features work reliably and are done in intuitive manner - user can quickly understand how to work with all the components. The most notable missing feature is easy simulation of input - this can be done via ALT web interface but if someone is looking for only editing FAs and simulating whether input string is accepted, they have to transition between two interfaces. The benefit is that they can then tap into all the other funcionality that ALT offers. The author of Statemaker has chosen React and Typescript as underlying technologies \cite{state-maker}.

\begin{figure}
    \includegraphics[width=\textwidth]{statemaker}
    \caption{Statemaker screenshot}\label{statemaker-screen}
\end{figure}

\subsection{Other Existing Applications}

As the main goal of this thesis is to write a finite automata editor for iPad, in this part I will study existing applications mainly for touch devices. 

One of such applications is TuringSim \cite{turingsim}. Although, it is not for FAs but for a Turing machine, it also consists of an editor where user can add and edit states and transitions, thus making it similar to a FA editor. You can see its interface in figure \ref{turingsim-screen}. This editors lets users add and edit automaton's states and transitions. Users can also simulate input on the Turing machine's read-and-write tape. Editing of the automaton is done only via tap gestures which is similar to Statemaker with the difference that there are no distinct buttons for those actions. Therefore, it does not fully utilize the potential of touch devices as the UX is very similar to what would one experience on the web. Unfortunately, the app on iPad is broken at the moment as it is missing bottom toolbar for simulating input.

There is also app called Finite Automata \cite{finite-automata-app}. In this app user can not edit automata in their weighted graph representation but instead has to use a command line that takes individual command which are described in the app. This app does not utilize touch device features at all.

There are also apps available as desktop applications. One is a Finite Automaton Editor by Jaime Rangel-Mondragon that is available as interactive Wolfram notebook \cite{wolfram-editor}. This app allows you to edit the automaton via a transition table and does not allow to simulate any input. There is also Automata Editor by Max Shawabkeh \cite{automata-editor-max}. In this desktop applications users can create and edit their automaton either via a table representation or regular expression. There are also features such as NFA determinization, evaluating automata on strings, and minimizing DFA. Thus it has a powerful feature set but one has to be already familiar with FA theory. It should also be noted that the feature set is a subset of what ALT web interface offers.

\begin{figure}
    \includegraphics[width=\textwidth]{turingsim}
    \caption{TuringSim interface screenshot}\label{turingsim-screen}
\end{figure}

\section{ALT}

Now I will go over ALT and its features that can be leveraged for simulating FA input. The code of ALT is available on GitLab \cite{gitlab} where there are multiple repositories in group Algorithms Library Toolkit (webui-client, infrastructe, etc.) - that includes repository Algorithms Library Toolkit Core \cite{alt-code}, a library written in C++ \cite{c++}. There we can find algorithms that can later be used for FA editor. The code is divided into multiple modules that are then built and linked together using CMake \cite{cmake}. The most important module for this thesis are \textit{alib2data} and \textit{alib2algo} where alib2data contains FA models and alib2algo algorithms for simulating input.

\subsection{FA Model}

Multiple FA types are supported by ALT - that includes deterministic and nondeterministic finite automaton as well as nondeterministic finite automaton with $\epsilon-transitions$. There is also extended NFA that has regular expressions as their transitions. These models serve as a definition of an automaton - its states, transitions, etc. To create e.g. NFA with $\epsilon-transitions$ one can use its constructor where it is possible to specify its states and input alphabet. For adding transitions there is a method called \lstinline{addTransition}. Both can be seen in figure \ref{epsilon-nfa-methods}.

\begin{figure}
    \begin{lstlisting}
        // Creates a new instance of the Automaton
        // with a concrete initial state.
        explicit EpsilonNFA ( 
            ext::set < StateType > states,
            ext::set < SymbolType > inputAlphabet, 
            StateType initialState, 
            ext::set < StateType > finalStates
        );
        // Add a transition to the automaton.
        bool addTransition ( 
            StateType from,
            common::symbol_or_epsilon < SymbolType > input,
            StateType to 
        );
    \end{lstlisting}
    \caption{EpsilonNFA example methods}\label{epsilon-nfa-methods}
\end{figure}

\subsection{FA Algorithms}

ALT offers multitude of algorithms that can be run on finite automata - such as minimization, determinization, and simulating input. Simulating input can be found in \lstinline{Accept.h} and \lstinline{Run.h}. Where the former is able to determine whether an input is accepted and the latter does the same but a part of its output is also e.g. in which states did the simulation end in.

\section{Strokes Recognition}

The final prototype will include recognizing automaton elements from drawing. In this section I will go over available methods of how to achieve it.

\subsection{Google ML Kit}

Google offers a framework called ML Kit that includes what they call "Digital Ink Recognition". This lets you construct a stroke from points drawn on the screen and create \lstinline{Ink} object from those strokes. It also includes base models for recognizing text and even some basic shapes like arrow and rectangle. If you want to create your own model with TensorFlow Lite \cite{tensorflow}, you are forced to use "Image Labeling". Since the editor should support creating cycles, it is necessary to create a custom model because that shape is not supported by any of the base models for Digital Ink Recognition.

\subsection{Core ML}

Apple's CoreML framework supports variety of use cases - analysis of images, processing text, converting audio to text, and identifying sounds in audio \cite{coreml}. It does not, however, support anything like Digital Ink Recognition. For the editor it is suitable to use analysis of images because it is possible to create an image from the screen and pass that to the model. Apple also provides some models already in CoreML format \cite{coreml-models}. Not any of them are applicable for the FA editor's use case. Therefore, a custom model for CoreML would be necessary as well.

Considering that CoreML is bundled in the system and Google ML Kit needs to be installed separately, increasing app's size and incurring maintenance burden, I opted for CoreML. This decision was also made based on the fact that both frameworks do support TensorFlow, although, for CoreML it needs to be first converted to its format.

\subsection{Creation of CoreML Model}

There are multiple ways how to create CoreML model, though, they generally fall into two categories:
\begin{itemize}
    \item ML model created by ML libraries that are not from Apple such as TensorFlow or Keras \cite{keras} and then converted with coremltools \cite{coremltools}.
    \item ML model created by framework or application that outputs CoreML directly.
\end{itemize}

For creating CoreML models directly there is either Create ML \cite{create-ml} or turicreate \cite{turicreate}. Create ML, at the time of writing, supports only image classification, whereas turicreate has built-in support for drawing classification. Although, both image classification and drawing classification operate on images, the important distinction is that drawing classification 28x28 grayscale bitmap as input. The drawing classification is also tailored for inputs created by Apple Pencil \cite{drawing-classification}, thus I have chosen to use it instead of libraries such as TensorFlow. It should be noted, though, that turicreate leverages TensorFlow as a lower-level framework and it should serve to streamline development of CoreML models.

\chapter{Automata Editor Design}
\label{chap:design}

In this chapter I will go over some decisions made, such as which technology I have decided to use, and over the design of the editor - how the app will look and how users will interact with the editor.

\section{Touch Device}
The main reason why this prototype is meant for a touch device is to simulate as much as possible the experience of drawing FAs on a paper. There were three main options that were possible:
\begin{itemize}
    \item create touch-friendly web interface
    \item implement app for Android
    \item target iPad devices
\end{itemize}
Creating a touch-friendly web interface would have the benefit of being universal and not tied to a specific platform. But native apps offer better precision and developers can tap into OS APIs that are tailored for touch. The choice between Android and iPad was less clear but iPad has the benefit of Apple Pencil \cite{apple-pencil} that offers high precision that will make the user experience better.

\section{Used Technologies}

I will now cover what technologies are used in the app and why I have chosen them. A lot of decisions have been influenced by focusing on iPad, and even more specifically, usage of the app on iPad along with Apple Pencil. 

\subsection{Language}

Choosing a language in which one will write the application is an important first step. For iOS applications I could have used:
\begin{itemize}
    \item Objective-C
    \item Swift
    \item cross-platform framework
\end{itemize}

Objective-C was designed by Brad J. Cox at the start of 1980s and was then licensed by NeXT Software in 1988. Then in 1996 NeXT Software was acquired by Apple - along with Objective-C. Apple have then chosen Objective-C as a main language for OS X and in 2007 for the new operating system iOS \cite{objective-c-programming}. On the Apple developer website it is described as "superset of the C programming language and provides object-oriented capabilities and a dynamic runtime" \cite{objective-c}. Objective-C has been thus the main programming language for years. Nowadays, Objective-C is not anymore that popular and ranks at the 23rd place as per TIOBE index \cite{tiobe-index}. Apple has rather shifted their focus to Swift and some of the new frameworks, like SwiftUI \cite{swiftui}, are only available in Swift. Swift is thus a much better option to choose if one is starting a new iOS app.

Using a cross-platform framework - such as React Native \cite{react-native} or Flutter \cite{flutter} - was also a possibility. But to leverage Apple Pencil fully it was necessary to use PencilKit \cite{pencilkit} and for this one would have to write native code. Therefore, I have decided to use Swift as the main language.

\subsection{UI Framework}

At the time of writing it is possible to use two UI frameworks offered by Apple to write UI code. Those are UIKit \cite{uikit} or, already mentioned, SwiftUI \cite{swiftui}. SwiftUI is a newer framework than UIKit, release in 2019 \cite{swiftui-release}. In Thinking in SwiftUI book it is described as "radical departure from UIKit, AppKit, and other object-oriented UI frameworks" \cite{thinking-in-swiftui}. SwiftUI offers a more declarative approach, quite similar to React \cite{react} used in the web development. Declarative UIs have the benefits of less code since it enables the framework to do more on behalf of the developers. This comes at a cost of lesser control. Getting back to SwiftUI, specifically, one of its major drawbacks is that not all components, that are written in UIKit, are available in SwiftUI. But there is very strong support for SwiftUI-UIKit interoperability \cite{swiftui-interop} and thus it is always possible to use UIKit when necessary. The fact that SwiftUI offers faster development due to its declarative nature and also SwiftUI previews \cite{swiftui-preview} has made it a better candidate than UIKit, especially for a prototype. Therefore, I decided to use SwiftUI as the main UI framework.

\subsection{Architecture}

There is no recommended architecture by Apple for apps written on top of SwiftUI frameworks. It is also entirely possible to create an app without adhering to any architecture. This code, though, is more difficult to maintain for a longer period.

One possible architecture is MVVM \cite{mvvm}. Diagram of this architecture can be seen in figure \ref{mvvm}. It enables developers to have a clear boundary between UI code and business logic and is a good option for either UIKit or SwiftUI applications. One of its drawbacks is that it can sometimes lead to imperative code where developers call a function and act based on its inputs. The alternative are (among others) architectures inspired by Redux. Diagram of Redux is depicted in figure \ref{redux}. The main difference between Redux and MVVM is that MVVM is event-driven whereas Redux is data-driven. Data-driven approach is much more closer to declarative programming since the state of the application describes how it should look. Thus I have decided that Redux-like architecture will be a better option.

One of concrete implementations of Redux architecture is the Composable Architecture by Point-Free \cite{tca}. This architecture is based on Redux but it has some modifications such as handling of side effects. It also makes testing more exhaustive by asserting that no action that you do not expect is run as well as that the state is not changed in any other way than you describe in your test. Considering all of the points given, I have chosen to use the Composable Architecture. 

\begin{figure}
    \includegraphics[width=\textwidth]{mvvm}
    \caption{MVVM architecture diagram \cite{mvvm}}\label{mvvm}
\end{figure}

\begin{figure}
    \includegraphics[width=\textwidth]{redux}
    \caption{Redux architecture diagram \cite{react-redux}}\label{redux}
\end{figure}

\section{ALT Integration}

I have already talked about ALT in chapter \ref{chap:analysis}. I have not discussed there, however, how ALT will be integrated in the application. That is now possible as I have stated that the app will be written in Swift. As already mentioned, ALT is a library written in C++. There exists a Swift-C++ interoperability manifesto \cite{swift-c++-manifesto}. This manifesto goes over what it would take to make C++ and Swift interoperable but not even all functionalities of C++ have their discussions of how they could be ported to Swift. However, there is a well-supported interoperability between Swift and Objective-C \cite{swift-objc-interoperability}. For Objective-C and C++ interoperability there is a language iteration of Objective-C called Objective-C++. It is even possible to "include pointers to Objective-C objects as data members of C++ classes" \cite{objc++}. I first tried to integrate ALT directly and compile it right via Xcode but due to the fact that ALT is built via CMake \cite{cmake} and does not have a simple setup, I then resorted to pre-building and then bundle the already built frameworks in the application. I will go over the details in \ref{chap:implementation}.

\section{User Interface}

As a final section of this chapter I will go over the design of UI. The design has been heavily influenced by the fact that one of the main goals was to imitate the experience of drawing FAs on a piece of paper. The app should let users to:
\begin{itemize}
    \item create FA states, transitions, and cycles
    \item delete and rearrange all of the above
    \item name states
    \item specify symbols for transitions
    \item simulate input and see whether the input was or was not accepted by the automaton
\end{itemize}

\subsection{Canvas}

Canvas is the most important part of the editor since it is the space where user can draw FA elements. After each individual stroke, a function will be run that will evaluate the stroke to determine which FA state the user has drawn. The flow of recognizing the FA elements is graphically represented in figure \ref{app-flow}. The app first waits for the user to make a stroke, after a stroke is made its representation is sent to the ML model which recognizes the type of FA element, a state is updated with the new element and it is drawn on the canvas. Then the app again waits for another stroke.

\begin{figure}
    \includegraphics[width=\textwidth]{app-flow}
    \caption{Flow of recognizing FA elements from strokes}\label{app-flow}
\end{figure}

\subsection{State}

The app needs to be able to work with three FA elements - state, transitions and a cycle (a special case of transition that starts and ends in the same state). These elements should be represented the same way as they are in the weighted directed graph representation. That means a state will be rendered as a circle. But it is necessary to also enable user to edit the name of the state. Thus, a text field in the center of the state will be shown. You can see example of a stroke that should be rendered as a state and how it looks like after being recognized in figure \ref{state}. Notice also a button at the top of the circle - this button is for dragging the state. To indicate that the state is final, user should be able to draw another circle where the stroke contains the center of the state that should be final. In figure \ref{final-state} you should see examples of strokes that should be then rendered as a final state.

\begin{figure}
    \centering
    \subfigure[Stroke]{\includegraphics[width=0.4\textwidth]{state-stroke}}
    \subfigure[Rendered state]{\includegraphics[width=0.4\textwidth]{state}}
    \caption{Example of a state stroke (a) and how it is rendered (b)}\label{state}
\end{figure}

\begin{figure}
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{final-stroke-1}}
    \subfigure[]{\includegraphics[width=0.4\textwidth]{final-stroke-2}}
    \subfigure[]{\includegraphics[width=0.4\textwidth]{final-stroke-3}}
    \subfigure[]{\includegraphics[width=0.4\textwidth]{final-state}}
    \caption{(a), (b), (c) are example strokes that should be rendered as a final state (d)}\label{final-state}
\end{figure}

\subsection{Transition}

A transition is represented as a directed edge between vertices which is a shape of an arrow. The stroke can either be as an arrow or, more conveniently, just a straight line which is faster and easier to draw, especially when the shape must be drawn with a single stroke. Example strokes and a rendered transition are in figure \ref{transition}. Note that the transition can be drawn in no matter which direction. The transition has also a text field positioned above its middle point. Apart from this text field where users can write symbols that the transition should occur on there is also a button with a plus icon. This button allows users to add multiple symbols to a single transition. Leveraging a delimiter, such as comma, was also considered but that could inhibit discoverability. Users can easily remove the transition symbols by tapping a cross symbol beside the symbol. To enable drawing FA with $\epsilon-transitions$ there is also a button with $\epsilon$. When it is tapped, it is added as another symbol for that particulat transitions. A transition with multiple symbols and with $\epsilon-transition$ are in figure \ref{transition-symbols}. Similar to a state there is a drag button to drag the middle point of a transition. This is especially useful when having multiple states on the same horizontal line with a transition going from the leftmost to the rightmost state.

\begin{figure}
    \centering
    \subfigure[]{\includegraphics[width=0.4\textwidth]{transition-stroke-1}}
    \subfigure[]{\includegraphics[width=0.4\textwidth]{transition-stroke-2}}
    \subfigure[]{\includegraphics[width=0.4\textwidth]{transition-stroke-3}}
    \subfigure[]{\includegraphics[width=0.4\textwidth]{transition}}
    \caption{(a), (b), (c) are example strokes that should be rendered as a transition (d)}\label{transition}
\end{figure}

\begin{figure}
    \centering
    \subfigure[Transition with multiple symbols]{\includegraphics[width=0.4\textwidth]{transition-multiple}}
    \subfigure[$\epsilon-transition$]{\includegraphics[width=0.4\textwidth]{transition-epsilon}}
    \caption{Transitions with symbols}\label{transition-symbols}
\end{figure}

\chapter{Implementation}
\label{chap:implementation}

\chapter{User Testing}

\chapter{Conclusion}

\section{Goals Assessment}

Assess my goals.

\section{Thesis Contribution}

The contribution of this thesis is testing Algorithms Library Toolkit in practice and can now be pointed to for users who want to see its capabilities. The editor can now also be recommended in the course of BI-AAG at FIT CTU (and other universities) - for students and teachers alike.

\section{Future Work}

Algorithms Library Toolkit is an extensive library and there are still capabilites that are not implemented in the editor.

The choice of developing a native iOS application has resulted in good UX, but in the future it would be beneficial to broaden the possible audience and either develop a similar Android app or create a more ubiquituous web interface.
